'use strict';

var merge = require('merge');
var assert = require('assert');
var crypto = require('crypto');
var ReadableStream = require('readable-stream');
var inherits = require('util').inherits;

/**
 * Create a readable stream of random data
 * @extends {ReadableStream}
 * @constructor
 * @param {Object} options
 * @param {Number} options.
 * @param {Number} options.
 * @param {Number} options.
 */
function RandomStream(options) {
  if (!(this instanceof RandomStream)) {
    return new RandomStream(options);
  }

  this._options = merge(Object.create(RandomStream.DEFAULTS), options);

  assert(typeof this._options.length === 'number', 'Invalid length supplied');
  assert(typeof this._options.size === 'number', 'Invalid size supplied');
  assert(typeof this._options.hash === 'string', 'Invalid hash alg supplied');

  this.hash = crypto.createHash(this._options.hash);
  this.bytes = 0;

  ReadableStream.call(this);
}

inherits(RandomStream, ReadableStream);

RandomStream.DEFAULTS = {
  length: Infinity,
  size: 512,
  hash: 'sha256'
};

/**
 * Implements the underlying _read source
 * @private
 */
RandomStream.prototype._read = function() {
  var self = this;
  var numbytes = this._getNextChunkSize();

  if (numbytes === 0) {
    this.hash = this.hash.digest();
    this.push(null);
  } else {
    crypto.randomBytes(numbytes, function(err, bytes) {
      if (err) {
        return self.emit('error', err);
      }

      self.bytes += numbytes;
      
      self.hash.update(bytes);
      self.push(bytes);
    });
  }
};

/**
 * Calculates the size of the next chunk
 * @private
 */
RandomStream.prototype._getNextChunkSize = function() {
  var length = this._options.length;
  var remaining = length - this.bytes;

  if (remaining >= this._options.size) {
    return this._options.size;
  }

  return remaining;
};

module.exports = RandomStream;
